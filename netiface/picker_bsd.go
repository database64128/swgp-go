//go:build darwin || dragonfly || netbsd || openbsd

package netiface

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"net/netip"
	"os"
	"sync"
	"sync/atomic"

	"github.com/database64128/swgp-go/conn"
	"github.com/database64128/swgp-go/tslog"
	"golang.org/x/net/route"
	"golang.org/x/sys/unix"
)

func (*PickerConfig) newPicker(logger *tslog.Logger) (*Picker, error) {
	p := Picker{
		picker: picker{
			logger:                 logger,
			defaultRoute4ByIfindex: make(map[int]defaultRoute4),
			defaultRoute6ByIfindex: make(map[int]defaultRoute6),
		},
	}
	p.pktinfo4p.Store(&conn.Pktinfo{})
	p.pktinfo6p.Store(&conn.Pktinfo{})
	return &p, nil
}

type picker struct {
	logger                 *tslog.Logger
	defaultRoute4ByIfindex map[int]defaultRoute4
	defaultRoute6ByIfindex map[int]defaultRoute6
	pktinfo4               conn.Pktinfo
	pktinfo6               conn.Pktinfo
	pktinfo4p              atomic.Pointer[conn.Pktinfo]
	pktinfo6p              atomic.Pointer[conn.Pktinfo]
	wg                     sync.WaitGroup
}

func (p *picker) start(ctx context.Context) error {
	fd, err := newRoutingSocket()
	if err != nil {
		return fmt.Errorf("failed to open routing socket: %w", err)
	}
	f := os.NewFile(uintptr(fd), "route")

	// Fetch and handle initial route dump.
	rib, err := route.FetchRIB(unix.AF_UNSPEC, route.RIBTypeRoute, 0)
	if err != nil {
		_ = f.Close()
		return fmt.Errorf("failed to fetch route messages: %w", err)
	}
	p.handleRouteMessage(rib)

	// Start listening for route updates.
	p.wg.Add(1)
	go func() {
		p.monitorRoutingSocket(f)
		_ = f.Close()
		p.wg.Done()
	}()

	// Stop on context cancellation.
	if ctxDone := ctx.Done(); ctxDone != nil {
		go func() {
			<-ctxDone
			if err := f.SetReadDeadline(conn.ALongTimeAgo); err != nil {
				p.logger.Error("Failed to set read deadline on routing socket", tslog.Err(err))
			}
		}()
	}

	p.logger.Info("Started interface picker")
	return nil
}

func (p *picker) monitorRoutingSocket(f *os.File) {
	// route(8) monitor uses this buffer size.
	// Each read only returns a single message.
	const readBufSize = 2048
	b := make([]byte, readBufSize)
	for {
		n, err := f.Read(b)
		if err != nil {
			if errors.Is(err, os.ErrDeadlineExceeded) {
				break
			}
			p.logger.Error("Failed to read from routing socket", tslog.Err(err))
			continue
		}
		p.handleRouteMessage(b[:n])
	}
}

func (p *picker) handleRouteMessage(b []byte) {
	rmsgs, err := route.ParseRIB(route.RIBTypeRoute, b)
	if err != nil {
		p.logger.Error("Failed to parse route messages", tslog.Err(err))
		return
	}

	clear(p.defaultRoute4ByIfindex)
	clear(p.defaultRoute6ByIfindex)

	for _, msg := range rmsgs {
		switch msg := msg.(type) {
		case *route.RouteMessage:
			switch msg.Type {
			case unix.RTM_ADD, unix.RTM_DELETE, unix.RTM_CHANGE:
			case unix.RTM_GET:
				// For RTM_GET messages, we only care about the ones generated by our FetchRIB call.
				// On macOS, RTM_GET messages received from FetchRIB have its rtm_pid set to 0.
				// We assume this is the case on all BSDs.
				if msg.ID != 0 {
					continue
				}
			default:
				continue
			}

			if msg.Flags&unix.RTF_UP == 0 ||
				msg.Flags&unix.RTF_GATEWAY == 0 ||
				msg.Flags&unix.RTF_HOST != 0 {
				continue
			}

			if msg.Index == 0 {
				continue
			}

			dstAddr := addrFromRouteAddr(msg.Addrs[unix.RTAX_DST])
			if !dstAddr.IsUnspecified() {
				continue
			}

			netmaskAddr := addrFromRouteAddr(msg.Addrs[unix.RTAX_NETMASK])
			if !netmaskAddr.IsUnspecified() {
				continue
			}

			ifaAddr := addrFromRouteAddr(msg.Addrs[unix.RTAX_IFA])
			if !ifaAddr.IsValid() {
				continue
			}

			if p.logger.Enabled(slog.LevelDebug) {
				p.logger.Debug("Discovered default route",
					slog.Int("rtmType", msg.Type),
					slog.Int("rtmIndex", msg.Index),
					tslog.Uint("rtmPid", msg.ID),
					tslog.Addr("ifaAddr", ifaAddr),
				)
			}

			if ifaAddr.Is4() {
				p.defaultRoute4ByIfindex[msg.Index] = defaultRoute4{
					rtmType: msg.Type,
					ifaAddr: ifaAddr,
				}
			} else {
				// Unlike IPv4, the IPv6 address in a default route message is a link-local address.
				p.defaultRoute6ByIfindex[msg.Index] = defaultRoute6{
					rtmType: msg.Type,
				}
			}
		}
	}

	if len(p.defaultRoute4ByIfindex) == 0 && len(p.defaultRoute6ByIfindex) == 0 {
		return
	}

	af := unix.AF_UNSPEC
	switch {
	case len(p.defaultRoute4ByIfindex) == 0:
		af = unix.AF_INET6
	case len(p.defaultRoute6ByIfindex) == 0:
		af = unix.AF_INET
	}

	rib, err := route.FetchRIB(af, route.RIBTypeInterface, 0)
	if err != nil {
		p.logger.Error("Failed to fetch route messages", tslog.Err(err))
		return
	}

	rmsgs, err = route.ParseRIB(route.RIBTypeInterface, rib)
	if err != nil {
		p.logger.Error("Failed to parse route messages", tslog.Err(err))
		return
	}

	var ifindex int

	for _, msg := range rmsgs {
		switch msg := msg.(type) {
		case *route.InterfaceMessage:
			if _, ok4 := p.defaultRoute4ByIfindex[msg.Index]; !ok4 {
				if _, ok6 := p.defaultRoute6ByIfindex[msg.Index]; !ok6 {
					continue
				}
			}

			if msg.Flags&unix.IFF_UP == 0 ||
				msg.Flags&unix.IFF_RUNNING == 0 ||
				msg.Flags&unix.IFF_LOOPBACK != 0 ||
				msg.Flags&unix.IFF_POINTOPOINT != 0 {
				continue
			}

			ifindex = msg.Index

		case *route.InterfaceAddrMessage:
			if msg.Index != ifindex {
				continue
			}

			// These constants have common values across supported BSD variants.
			//
			//   - macOS: https://github.com/apple-oss-distributions/xnu/blob/94d3b452840153a99b38a3a9659680b2a006908e/bsd/netinet6/in6_var.h#L785-L821
			//   - DragonFly BSD: https://github.com/DragonFlyBSD/DragonFlyBSD/blob/ba1276acd1c8c22d225b1bcf370a14c878644f44/sys/netinet6/in6_var.h#L457-L472
			//   - FreeBSD: https://github.com/freebsd/freebsd-src/blob/7bbcbd43c53b49360969ca82b152fd6d971e9055/sys/netinet6/in6_var.h#L492-L505
			//   - NetBSD: https://github.com/NetBSD/src/blob/2b3021f92cac3b692b6b23305b68f7bb4212bffd/sys/netinet6/in6_var.h#L400-L417
			//   - OpenBSD: https://github.com/openbsd/src/blob/c0b7aa147b16eeebb8c9dc6debf303af3c74b7d5/sys/netinet6/in6_var.h#L287-L293
			const (
				IN6_IFF_DEPRECATED = 0x10
				IN6_IFF_TEMPORARY  = 0x80
			)
			if msg.Flags&IN6_IFF_DEPRECATED != 0 || msg.Flags&IN6_IFF_TEMPORARY != 0 {
				continue
			}

			ifaAddr := addrFromRouteAddr(msg.Addrs[unix.RTAX_IFA])
			if !ifaAddr.IsValid() || ifaAddr.IsLinkLocalUnicast() {
				continue
			}

			if p.logger.Enabled(slog.LevelDebug) {
				p.logger.Debug("Processing interface address",
					slog.Int("ifindex", msg.Index),
					tslog.Addr("ifaAddr", ifaAddr),
				)
			}

			if ifaAddr.Is4() {
				rtm4, ok := p.defaultRoute4ByIfindex[msg.Index]
				if !ok {
					continue
				}
				if rtm4.ifaAddr != ifaAddr {
					continue
				}
				delete(p.defaultRoute4ByIfindex, msg.Index)
				switch rtm4.rtmType {
				case unix.RTM_ADD, unix.RTM_CHANGE, unix.RTM_GET:
					if p.pktinfo4.Addr != rtm4.ifaAddr || int(p.pktinfo4.Ifindex) != msg.Index {
						pktinfo4 := conn.Pktinfo{
							Addr:    rtm4.ifaAddr,
							Ifindex: uint32(msg.Index),
						}
						p.logger.Info("Updating default pktinfo4",
							tslog.Addr("oldAddr", p.pktinfo4.Addr),
							tslog.Uint("oldIfindex", p.pktinfo4.Ifindex),
							tslog.Addr("newAddr", pktinfo4.Addr),
							tslog.Uint("newIfindex", pktinfo4.Ifindex),
						)
						p.pktinfo4 = pktinfo4
						p.pktinfo4p.Store(&pktinfo4)
					}
				case unix.RTM_DELETE:
					if p.pktinfo4.Addr == rtm4.ifaAddr && int(p.pktinfo4.Ifindex) == msg.Index {
						p.logger.Info("Deleting default pktinfo4",
							tslog.Addr("oldAddr", p.pktinfo4.Addr),
							tslog.Uint("oldIfindex", p.pktinfo4.Ifindex),
						)
						p.pktinfo4 = conn.Pktinfo{}
						p.pktinfo4p.Store(&conn.Pktinfo{})
					}
				default:
					panic("unreachable")
				}
			} else {
				rtm6, ok := p.defaultRoute6ByIfindex[msg.Index]
				if !ok {
					continue
				}
				delete(p.defaultRoute6ByIfindex, msg.Index)
				switch rtm6.rtmType {
				case unix.RTM_ADD, unix.RTM_CHANGE, unix.RTM_GET:
					if p.pktinfo6.Addr != ifaAddr || int(p.pktinfo6.Ifindex) != msg.Index {
						pktinfo6 := conn.Pktinfo{
							Addr:    ifaAddr,
							Ifindex: uint32(msg.Index),
						}
						p.logger.Info("Updating default pktinfo6",
							tslog.Addr("oldAddr", p.pktinfo6.Addr),
							tslog.Uint("oldIfindex", p.pktinfo6.Ifindex),
							tslog.Addr("newAddr", pktinfo6.Addr),
							tslog.Uint("newIfindex", pktinfo6.Ifindex),
						)
						p.pktinfo6 = pktinfo6
						p.pktinfo6p.Store(&pktinfo6)
					}
				case unix.RTM_DELETE:
					if p.pktinfo6.Addr == ifaAddr && int(p.pktinfo6.Ifindex) == msg.Index {
						p.logger.Info("Deleting default pktinfo6",
							tslog.Addr("oldAddr", p.pktinfo6.Addr),
							tslog.Uint("oldIfindex", p.pktinfo6.Ifindex),
						)
						p.pktinfo6 = conn.Pktinfo{}
						p.pktinfo6p.Store(&conn.Pktinfo{})
					}
				default:
					panic("unreachable")
				}
			}
		}
	}

	for ifindex, rtm4 := range p.defaultRoute4ByIfindex {
		if rtm4.rtmType == unix.RTM_DELETE && p.pktinfo4.Addr == rtm4.ifaAddr && int(p.pktinfo4.Ifindex) == ifindex {
			p.logger.Info("Deleting default pktinfo4",
				tslog.Addr("oldAddr", p.pktinfo4.Addr),
				tslog.Uint("oldIfindex", p.pktinfo4.Ifindex),
			)
			p.pktinfo4 = conn.Pktinfo{}
			p.pktinfo4p.Store(&conn.Pktinfo{})
		}
	}

	for ifindex, rtm6 := range p.defaultRoute6ByIfindex {
		if rtm6.rtmType == unix.RTM_DELETE && int(p.pktinfo6.Ifindex) == ifindex {
			p.logger.Info("Deleting default pktinfo6",
				tslog.Addr("oldAddr", p.pktinfo6.Addr),
				tslog.Uint("oldIfindex", p.pktinfo6.Ifindex),
			)
			p.pktinfo6 = conn.Pktinfo{}
			p.pktinfo6p.Store(&conn.Pktinfo{})
		}
	}
}

type defaultRoute4 struct {
	rtmType int
	ifaAddr netip.Addr
}

type defaultRoute6 struct {
	rtmType int
}

func addrFromRouteAddr(ra route.Addr) netip.Addr {
	switch ra := ra.(type) {
	case *route.Inet4Addr:
		return netip.AddrFrom4(ra.IP)
	case *route.Inet6Addr:
		return netip.AddrFrom16(ra.IP) // We don't need zone info here.
	default:
		return netip.Addr{}
	}
}

func (p *picker) stop() error {
	p.wg.Wait()
	p.logger.Info("Stopped interface picker")
	return nil
}

func (*picker) requestPoll() {}

func (p *picker) default4() *atomic.Pointer[conn.Pktinfo] {
	return &p.pktinfo4p
}

func (p *picker) default6() *atomic.Pointer[conn.Pktinfo] {
	return &p.pktinfo6p
}
